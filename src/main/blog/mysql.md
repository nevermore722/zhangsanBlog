## mysql底层数据结构
通常mysql的存储引擎分为myisam和innodb，两者底层的数据结构都是B+树。<br>
通常B+树的层高比较低，每个叶子节点默认能存储16KB数据
## 为什么使用B+树
为了尽可能的存储更多的数据，并减少查询次数，传统的二叉树是不够用的，需要引入多叉树的概念，于是有了多路平衡搜索树的B树。<br>
而B+树在B树的基础上更进一步，只在叶子节点上存储数据，在非叶子节点存储索引，可以进行更快的查询，并且范围搜索效果好。<br>
值得一提的是，较为火热的非关系型数据库redis底层使用的是跳表，也是很优秀的存储实现，B+树与跳表适合不同的场景，后面整理redis的时候详细说。
## 什么是索引
索引相当于字典的目录，是一种用于快速定位和检索数据的数据结构，通常索引底层通常也还是二叉树，非叶子节点存储索引的key，叶子节点存储数据主键或真实数据。<br>
索引能加快数据的查询效率，但是索引本身也会占用存储空间，数据变化后索引也会发生变化，因此不要滥用索引。
## 通常什么样的数据需要建索引
通常通过它经常需要进行查询的数据并且区分度高的数据需要建立索引，比如说订单号、商品ID等，区分度低的数据不要去建索引，比如说性别。<br>
另外如果数据经常需要更新，尽可能不要创建索引。表规模较小或者列存储的数据是长文本、也不适合创建索引。
## 如何实现事务
对于mysql来说是通过START TRANSACTION语法，结合mysql底层的undo log机制来实现的，如果两条语句不能同时完成，则会进行回滚数据（同时失败）。<br>
对于代码实现来说，一般是通过spring的@Transactional注解去实现的。
## 事务的传播行为
1. REQUIRED：默认的隔离级别，如果当前存在事务则加入，否则创建新事务，适合绝大部分业务。
2. SUPPORTS：如果当前存在事务则加入，否则已非事务方式执行，适合可非事务执行的查询方法。
3. MANDATORY：必须在事务中调用，否抛出异常。
4. REQUIRES_NEW：始终创建新事务，挂起当前事务，适合需独立执行的业务比如说记录日志。
5. NOT_SUPPORTED：强制非事务执行，挂起当前事务。
6. NEVER：禁止出现事务，否则跑出异常。
7. NESTED：嵌套事务，基于保存点实现。
## 事务的隔离级别以及解决了什么问题
1. 默认：与数据库有关，mysql为可重复读，oracle为读已提交。
2. 读未提交：允许读取未提交的数据，有可能出现脏读（读取到其他事务未提交的修改）的风险。
3. 读已提交：可避免脏读，但可能会有不可重复读（同一事务内多次读取不一致的的问题）的问题。
4. 可重复读：可解决不可重复读问题，但可能发生幻读（两次范围读取数据数量不一致）的问题。
5. 串行化：可解决所有问题，但是性能低。
如果既能解决幻读问题，又能保证性能？
- 可通过间隙锁实现
## 什么情况下事务会失效
## 什么是MVCC
## 通过什么机制实现主从同步
## 怎么实现分库分表