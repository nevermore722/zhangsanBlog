简单描述一下工作中用到的设计模式
## 单例模式
最常见的设计模式，主要用于创建单例的对象，常见的实现方式有懒汉式，饿汉式，双检锁，静态内部类，枚举等。<br>
通常在业务代码中或框架代码中看到xxx.getInstance()就能想到运用到了单例模式。<br>
开源框架中最经典是spring的单例bean，获取数据库连接池等代码也运用到了单例模式。
## 工厂模式
工厂模式又可分为简单工厂模式、工厂方法模式、抽象工厂模式。核心思路是让调用方依赖工厂类或接口来创建对象，因此完成了解耦操作，调用方与被调用方不直接依赖。<br>
基于这个思路其实未必需要完全套用工厂模式，业务与业务之间未必类似于工厂创建产品的关系，但仍可以中间通过创建一层接口来进行解耦。<br>
业务中常见的用到了工厂模式的代码通常为xxxFactory。
## 策略模式
策略模式是一种行为型设计模式，主要思想是将选择业务与业务的实现进行分离，通常存在一个根据不同常见选择不同策略的类和基于一个策略接口实现的一堆策略类。<br>
这样可以使我们的业务逻辑更加清晰，哪一种策略出现了问题可以更好地进行定位与发现。<br>
但缺点是每一种策略会多出一个实现类，使类膨胀的厉害。往往可以多借鉴这种写代码的思路，将调用逻辑与实现逻辑进行分离，但如果实现代码比较简单的话，未必需要以类的方式进行分开。<br>
常见的代码为实现了xxxHandler接口的handle方法的Handler类。
## 建造者模式
建造者模式主要用于复杂的对象，这个对象的创建所需的参数可以有很多种的情况。为了不写一大堆的构造方法，也不想允许set注入，并且可以格式化入参，可以使用建造者模式来进行实现。<br>
建造者模式的主要实现方式是通过一个中间的Builder接口，自定义入参，通常会返回被建造的对象，让使用方可以链式的进行build操作，在可任意组合入参的情况下还方便了用户知道自己填充了什么参数。<br>
通过lombok，我们可以非常简单的实现建造者模式，仅需使用@Builder注解即可。
## 适配器模式
设计原理可以类比适配不同国家插座的电源适配器，是为了解决client端能够调用不同的参数业务的场景。<br>
通常会在调用方与被调用方增加一个Adapter层，在Adapter层做好数据的转换与处理，使得调用方不用修改代码，可以调用有着不同参数的业务逻辑。<br>
## 责任链模式
责任链模式的设计思路可以参考链表的实现，需要做到当一个任务处理完成之后把任务交给下一棒，任务与任务间不直接有联系。主要用于解决任务流程较长且会经常改变组合的情况。<br>
具体实现思路是对每个任务设置允许设置下一个处理者，当上个处理者完成后，通过一定的代码机制执行下一个处理者。<br>
场景代码会设计一连串的Handler，把Handler与Handler之间通过设置next来串起来，设计一个方法来执行下一个handler。<br>
基于这个思路，我们的代码实现了一种下一步的任务可能不是一个而是一组的机制，通过CountDownLatch来实现判断一组任务结束并开始执行下一个任务。

## 状态机模式
主要为一种代码的设计思路，主要需要做到能明确知道在当前状态允许执行什么操作，以及做了这个操作会切换为什么状态。<br>
通常实现此类代码的核心要素是考虑好整个业务中的状态（State）、事件（Event）和动作（Action），自己在逻辑捋顺了后写出的代码就会比较优雅，不会出现来回判断的情况。<br>
常见于订单状态的扭转等有明确状态行为的场景。
