## 为什么要用redis
通常使用redis是为了解决传统业务下的各种痛点，redis存在诸多使用场景，例如：<br>
- 解决MySQL等传统数据库的性能瓶颈问题。
- 分布式服务共享缓存问题。
- 解决缓存持久性问题。
- 选择合适的redis数据结构去完成实际业务。
- redis实现消息队列。
- redis实现分布式锁
## redis的基础数据结构
通常认为redis有5种数据结构
1. string:即一个key对应一个字符串，字符串小于1MB时每次加倍现有的空间，字符串长度大于1MB时每次扩容1MB，最大长度为512MB，如果value是整数时，可进行自增
2. list:相当于java中的LinkedList，但实际底层用的是quicklist，可以将多个ziplist通过双向指针串起来使用，因此可以通过它模拟栈、堆，实现消息队列。
3. hash:相当于java中的HashMap，通过一个key能存储多个键值对，可以存储业务对象等结构型数据。
4. set:相当于java中的HashSet，元素唯一但无序，一般用于微信共同好友等去重场景。
5. zset:是一个有序的set，并且可以给每一个value赋予一个score作为排序权重，底层使用的是跳表（SkipList）的数据结构，可用于排行榜、按日期排序等业务场景。

另外在redis后续的更新过程中，出现了bitmap、HyperLogLog、stream、地理位置等数据结构
## 分布式锁（如何用redis实现）
首先分布式锁的核心思路就是，当一个服务获取到锁之后另一个服务就没法再获取到锁了。<br>
因此，可以通过redis的setnx命令去进行加锁，这样先setnx的服务获取到锁之后其他服务就没法再获取了，除非等到第一个服务使用del释放。<br>
但是这样有一个问题，如果第一个服务出现了问题一直不释放锁，就会导致死锁，所以可以通过增加expire命令增加超时时间来解决这个问题。<br>
但是还有一个问题，如果expire命令执行前服务挂了，仍有可能出现死锁问题，因此在redis2.8以后可以通过同时set ex和nx的命令进行设置。<br>
但是还有问题，如果超时了但其实第一个任务并没有结束，不应该释放锁，但实际后面服务已经能够获取锁了，就可能存在并发问题了，特别是第一个服务执行完之后还可能会把锁进行释放，导致后面锁乱套了。<br>
为了尽可能的解决这个问题，可以在加锁时设置一个随机数，保证只有加锁的服务能释放锁，并且需要引入lua脚本来保证这个操作具备原子性。<br>
但是之前说的可能因为超时释放锁的问题还是没有解决，因此需要引入看门狗机制自动续期。<br>
如果是redis集群部署的话还可能出现因为部分节点挂了导致获取锁不正常，还需要引入红锁（多数节点获取锁成功才算有效）机制。<br>
可真是一个复杂的事情啊，所以往往业务不会自己重新造轮子，可以选择比较成熟的方案比如说Redisson。
## redis实现消息队列
## redis的常见应用场景
## redis为什么快
## 如何实现redis持久化
## redis部署方式
## redis的过期策略
## 什么是LRU算法
## redis数据结构的底层实现